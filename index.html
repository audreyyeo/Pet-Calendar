<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pet Calendar</title>

    <!-- ===== PWA & ICON CONFIGURATION ===== -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#141414">
    
    <!-- Standard favicons for browsers -->
    <link rel="icon" type="image/png+xml" href="./android-chrome-512x512.png" />
    <link rel="icon" type="image/svg+xml" sizes="16x16" href="./favicon-16x16.svg" />
    <link rel="icon" type="image/svg+xml" sizes="32x32" href="./favicon-32x32.svg" />

    <!-- Apple Touch Icon for iOS devices -->
    <link rel="apple-touch-icon" href="./apple-touch-icon.svg" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Pet Calendar">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@100;400&display=swap" rel="stylesheet">

    <style>
      .font-roboto-mono {
        font-family: 'Roboto Mono', monospace;
      }
      @keyframes scale-in {
        from { transform: scale(0); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
      }
      .animate-scale-in {
        animation: scale-in 0.5s cubic-bezier(0.25, 0.1, 0.25, 1) both;
      }
    </style>
    
</head>
<body class="bg-[#141414]">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // --- Icon Components (replaces lucide-react dependency) ---
        const CustomIcon = (props) => (
            <svg width={props.size || 24} height={props.size || 24} viewBox="0 0 348 321" fill="currentColor" xmlns="http://www.w3.org/2000/svg" {...props}>
                <path d="M89.0205 272.969V290.565L34.9336 320.25V298.033L64.9775 281.767L34.9336 265.501V243.284L89.0205 272.969Z"/>
                <path d="M311.784 265.501L281.739 281.767L311.784 298.033V320.25L257.697 290.565V272.969L311.784 243.284V265.501Z"/>
                <path d="M207.515 284.204L189.301 292.597L173.091 260.077L156.847 292.665L139.238 284.133L163.604 235.646H183.113L207.515 284.204Z"/>
                <path d="M225.01 139.866C233.421 139.866 241.904 142.671 247.683 148.991C250.434 151.923 252.479 155.432 253.853 159.445C259.595 175.397 254.545 196.63 237.763 203.415C229.825 206.624 220.087 206.624 212.149 203.415C208.411 201.868 204.997 199.578 202.229 196.618C196.264 190.093 194 181.475 194 172.805C194 168.294 194.572 163.72 196.059 159.445C197.439 155.611 199.477 151.935 202.271 148.946C208.235 142.621 216.446 139.866 225.01 139.866ZM225.45 159C222.277 159 220.368 159.811 219.075 161.05C214.907 165.043 214.907 179.86 219.075 183.854C222.063 186.715 228.837 186.715 231.824 183.854C235.991 179.861 235.991 165.042 231.824 161.05C230.531 159.811 228.623 159 225.45 159Z"/>
                <path d="M196.512 107H145.487V91.5781H196.512V107Z"/>
                <path d="M45.9357 104.973H26L61.5252 1H81.4609L45.9357 104.973Z"/>
                <path d="M140.846 104.973H120.91L85.3848 1H105.32L140.846 104.973Z"/>
                <path d="M221.09 104.973H201.154L236.679 1H256.615L221.09 104.973Z"/>
                <path d="M316 104.973H296.064L260.539 1H280.475L316 104.973Z"/>
                <path d="M39 129.999C33.5 134.999 25.1659 145.935 21.5264 157.236C17.1678 171.337 18.9905 189.455 26.5039 202.068C30.5361 208.698 35.1602 213.974 40.3301 218.986C45.5 223.999 48.5391 226.246 48.5391 226.246H26.9766C23.106 223.39 19.6389 220.15 16.6084 216.401C6.99488 204.511 2.0001 189.358 2 174.123C2 168.748 2.5886 163.379 3.83398 158.148C5.06365 153.23 6.72608 148.382 8.95996 143.825C13.2462 135.253 19.323 127.805 26.9434 122H48.5391C48.5391 122 44.5 124.999 39 129.999Z"/>
                <path d="M308.539 129.999C314.039 134.999 322.373 145.935 326.013 157.236C330.371 171.337 328.549 189.455 321.035 202.068C317.003 208.698 312.379 213.974 307.209 218.986C302.039 223.999 299 226.246 299 226.246H320.562C324.433 223.39 327.9 220.15 330.931 216.401C340.544 204.511 345.539 189.358 345.539 174.123C345.539 168.748 344.95 163.379 343.705 158.148C342.475 153.23 340.813 148.382 338.579 143.825C334.293 135.253 328.216 127.805 320.596 122H299C299 122 303.039 124.999 308.539 129.999Z"/>
                <path d="M170.5 180C174.046 180 177.471 180.725 179.797 183.055C184.068 187.333 184.068 196.476 179.797 200.754C175.475 205.082 165.524 205.082 161.202 200.754C156.932 196.477 156.933 187.332 161.202 183.055C163.528 180.725 166.954 180 170.5 180Z"/>
                <path d="M116.061 139.866C124.471 139.866 132.955 142.671 138.733 148.991C141.485 151.923 143.529 155.432 144.903 159.445C150.646 175.397 145.596 196.63 128.813 203.415C120.876 206.624 111.138 206.624 103.2 203.415C99.4617 201.868 96.0475 199.578 93.2803 196.618C87.3147 190.093 85.0509 181.475 85.0508 172.805C85.0508 168.294 85.6225 163.72 87.1094 159.445C88.4897 155.611 90.528 151.935 93.3223 148.946C99.2861 142.621 107.497 139.866 116.061 139.866ZM116.501 159C113.328 159 111.419 159.811 110.126 161.05C105.958 165.043 105.958 179.86 110.126 183.854C113.113 186.715 119.888 186.715 122.875 183.854C127.042 179.861 127.042 165.042 122.875 161.05C121.582 159.811 119.673 159 116.501 159Z"/>
            </svg>
        );
        const ChevronLeft = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m15 18-6-6 6-6"/></svg>;
        const ChevronRight = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m9 18 6-6-6-6"/></svg>;
        const CalendarIcon = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>;
        const X = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>;
        const PlusCircle = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/></svg>;
        const Edit = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>;
        const Trash2 = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>;
        const List = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/></svg>;
        const Search = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>;
        const Smile = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" x2="9.01" y1="9" y2="9"></line><line x1="15" x2="15.01" y1="9" y2="9"></line></svg>;
        const MoreHorizontal = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>;
        const Eye = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>;
        const EyeOff = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/></svg>;
        const Info = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"></circle><line x1="12" x2="12" y1="16" y2="12"></line><line x1="12" x2="12.01" y1="8" y2="8"></line></svg>;
        const Trash = (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props.size || 24} height={props.size || 24} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1" strokeLinecap="round" strokeLinejoin="round" {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;


        // --- Helper Functions ---
        const isSameDay = (d1, d2) => {
            if (!d1 || !d2) return false;
            return d1.getFullYear() === d2.getFullYear() &&
                   d1.getMonth() === d2.getMonth() &&
                   d1.getDate() === d2.getDate();
        };

        const getEventDetails = (summary) => {
            const summaryLower = summary.toLowerCase();
            let type = 'default';
            let name = summary;
            const serviceMappings = {
                'walk': 'walk', 'drop-in': 'drop-in', 'house sit': 'boarding',
                'boarding': 'boarding', 'meet & greet': 'meet-and-greet',
            };
            for (const keyword in serviceMappings) {
                if (summaryLower.startsWith(keyword + ':') || summaryLower.startsWith(keyword + ' ')) {
                    type = serviceMappings[keyword];
                    name = summary.replace(new RegExp(`^${keyword}[:\\s]*`, 'i'), '').trim();
                    break;
                }
            }
            return { name, type };
        };

        const getColorForEventType = (type) => {
            switch (type) {
                case 'walk': return 'bg-[#3FADFB] text-[#3FADFB] border-[#3FADFB]/30';
                case 'drop-in': return 'bg-[#22C46F] text-[#22C46F] border-[#22C46F]/30';
                case 'boarding': return 'bg-[#C58FFE] text-[#C58FFE] border-[#C58FFE]/30';
                case 'meet-and-greet': return 'bg-[#FED440] text-[#FED440] border-[#FED440]/30';
                default: return 'bg-gray-500 text-gray-300 border-gray-500/30';
            }
        };

        const getBarColorForEventType = (type) => {
            switch (type) {
                case 'walk': return 'bg-[#3FADFB]';
                case 'drop-in': return 'bg-[#22C46F]';
                case 'boarding': return 'bg-[#C58FFE]';
                case 'meet-and-greet': return 'bg-[#FED440]';
                default: return 'bg-gray-400';
            }
        };

        const formatEventType = (type) => {
            if (type === 'meet-and-greet') return 'Meet & Greet';
            const words = type.replace('-', ' ').split(' ');
            return words.map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        };

        const formatTime = (d) => d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });

        const formatDateToYYYYMMDD = (date) => {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        };

        const parseDateTime = (dateString, timeString = '00:00') => {
            // This function correctly handles YYYY-MM-DD strings by splitting them,
            // which avoids the UTC timezone interpretation issue.
            const [year, month, day] = dateString.split('-').map(Number);
            const [hours, minutes] = timeString.split(':').map(Number);
            return new Date(year, month - 1, day, hours, minutes);
        };

        // --- React Components ---

        const PasswordScreen = ({ onCorrectPassword }) => {
            const [password, setPassword] = useState('');
            const [showPassword, setShowPassword] = useState(false);
            const [error, setError] = useState('');
            
            // --- CHANGE YOUR PASSWORD HERE ---
            const CORRECT_PASSWORD = 'mlem';
            
            const errorMessages = [
                'Oops, no treat for that! Try again.',
                'That bone didn’t fetch it. Try again.',
                'Sniff sniff… that\'s not quite right.',
                'Purr‑mission denied. Try again.',
                'Wrong password. The cat is unimpressed.'
            ];

            const handleSubmit = (e) => {
                e.preventDefault();
                if (password === CORRECT_PASSWORD) {
                    onCorrectPassword();
                } else {
                    const randomError = errorMessages[Math.floor(Math.random() * errorMessages.length)];
                    setError(randomError);
                    setPassword('');
                }
            };

            return (
                <div className="flex flex-col items-center justify-center h-screen bg-[#141414] text-white p-4">
                    <div className="w-full max-w-sm text-center">
                        <CustomIcon className="w-16 h-16 mx-auto mb-6 text-gray-400" />
                        <h1 className="text-2xl font-bold mb-6">Pet Calendar</h1>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div className="relative">
                                <input
                                    type={showPassword ? 'text' : 'password'}
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    placeholder="Meow-code?"
                                    className="w-full px-4 py-2 text-lg bg-white/5 border border-white/10 text-white rounded-full focus:outline-none focus:ring-2 focus:ring-white/20 text-center pr-12"
                                    autoFocus
                                />
                                <button
                                    type="button"
                                    onClick={() => setShowPassword(!showPassword)}
                                    className="absolute inset-y-0 right-0 px-4 flex items-center text-gray-400 hover:text-white"
                                >
                                    {showPassword ? <EyeOff size={20} /> : <Eye size={20} />}
                                </button>
                            </div>
                            <button
                                type="submit"
                                className="w-full px-4 py-2 font-semibold text-black bg-gray-200 rounded-full hover:bg-white transition-colors"
                            >
                                Unlock
                            </button>
                        </form>
                        {error && <p className="text-gray-400 mt-4">{error}</p>}
                    </div>
                </div>
            );
        };

        const InsightsPage = ({ events, currentDate, isSorted, setIsSorted }) => {
            
            const visualizationEvents = useMemo(() => {
                const year = currentDate.getFullYear();
                const startOfYear = new Date(year, 0, 1);
                const endOfYear = new Date(year, 11, 31, 23, 59, 59, 999);

                const yearEvents = events.filter(event => {
                    const eventStart = new Date(event.dtstart);
                    const eventEnd = new Date(event.dtend);
                    return eventStart <= endOfYear && eventEnd >= startOfYear;
                });

                const expandedEvents = [];
                yearEvents.forEach(event => {
                    let currentDay = new Date(event.dtstart);
                    let eventEndDay = new Date(event.dtend);

                    if (!isSameDay(new Date(event.dtstart), new Date(event.dtend)) && eventEndDay.getHours() === 0 && eventEndDay.getMinutes() === 0) {
                        eventEndDay.setDate(eventEndDay.getDate() - 1);
                    }

                    let loopStartDate = currentDay > startOfYear ? currentDay : startOfYear;
                    let loopEndDate = eventEndDay < endOfYear ? eventEndDay : endOfYear;
                    
                    loopStartDate = new Date(loopStartDate);
                    loopStartDate.setHours(0, 0, 0, 0);

                    while (loopStartDate <= loopEndDate) {
                        expandedEvents.push({
                            uid: `${event.uid}-${loopStartDate.toISOString()}`,
                            type: event.type,
                            summary: event.summary
                        });
                        loopStartDate.setDate(loopStartDate.getDate() + 1);
                    }
                });
                
                return expandedEvents;
            }, [events, currentDate]);

            const sortedEvents = useMemo(() => {
                if (!isSorted) {
                    return visualizationEvents.sort((a, b) => new Date(a.uid.split('_').pop()) - new Date(b.uid.split('_').pop()));
                }
                const serviceOrder = ['walk', 'drop-in', 'boarding', 'meet-and-greet', 'default'];
                const sorted = [...visualizationEvents].sort((a, b) => serviceOrder.indexOf(a.type) - serviceOrder.indexOf(b.type));
                
                const grouped = sorted.reduce((acc, event) => {
                    if (!acc[event.type]) {
                        acc[event.type] = [];
                    }
                    acc[event.type].push(event);
                    return acc;
                }, {});
                return Object.values(grouped).flat();
            }, [visualizationEvents, isSorted]);
            
            const groupedSortedEvents = useMemo(() => {
                 if (!isSorted) {
                     return { 'all': sortedEvents };
                 }
                 const grouped = {};
                 sortedEvents.forEach(event => {
                     if (!grouped[event.type]) {
                         grouped[event.type] = [];
                     }
                     grouped[event.type].push(event);
                 });
                 return grouped;
             }, [sortedEvents, isSorted]);

            const serviceCounts = useMemo(() => {
                return visualizationEvents.reduce((acc, event) => {
                    acc[event.type] = (acc[event.type] || 0) + 1;
                    return acc;
                }, {});
            }, [visualizationEvents]);

            const serviceTypes = [
                { type: 'walk', label: 'Walk' },
                { type: 'drop-in', label: 'Drop-in' },
                { type: 'boarding', label: 'Boarding' },
                { type: 'meet-and-greet', label: 'Meet & Greet' },
            ];

            return (
                <div className="p-4 h-full text-white flex flex-col flex-grow">
                     <div className="flex justify-between items-center mb-6">
                        <p className="text-left text-gray-400">
                           <span className="font-bold">{visualizationEvents.length}</span> total service days scheduled this year.
                        </p>
                     </div>
                     <div className="flex-grow rounded-lg overflow-y-auto">
                        {visualizationEvents.length > 0 ? (
                            Object.keys(groupedSortedEvents).map(groupKey => (
                                <div key={groupKey} className="mb-6">
                                    {isSorted && (
                                        <h3 className="text-sm text-gray-300 mb-2">
                                            <span className="font-bold">{formatEventType(groupKey)}:</span> <span className="font-normal">{serviceCounts[groupKey] || 0} Days</span>
                                        </h3>
                                    )}
                                    <div className="grid gap-2" style={{ gridTemplateColumns: 'repeat(15, minmax(0, 1fr))' }}>
                                        {groupedSortedEvents[groupKey].map((event, index) => (
                                            <div
                                                key={event.uid}
                                                className={`w-4 h-4 rounded-full mx-auto ${getBarColorForEventType(event.type)} animate-scale-in`}
                                                style={{ animationDelay: `${index * 5}ms` }}
                                                title={`${formatEventType(event.type)}: ${event.summary}`}
                                            ></div>
                                        ))}
                                    </div>
                                </div>
                            ))
                        ) : (
                             <div className="flex items-center justify-center h-full">
                                 <p className="text-gray-500">No scheduled activity for this year.</p>
                             </div>
                         )}
                     </div>
                     <div className="mt-6 rounded-lg">
                         <div className="flex flex-nowrap justify-center gap-x-3 overflow-x-auto">
                             {serviceTypes.map(service => (
                                 <div key={service.type} className="flex items-center gap-2 flex-shrink-0">
                                     <div className={`w-3 h-3 rounded-full ${getBarColorForEventType(service.type)} opacity-70`}></div>
                                     <span className="text-xs text-gray-300 font-roboto-mono">{service.label}</span>
                                 </div>
                             ))}
                         </div>
                     </div>
                </div>
            );
        };
        
        const SettingsPage = ({ hiddenEventTypes, onToggleEventType, onDeleteAllEvents }) => {
            const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
            const [showInfo, setShowInfo] = useState(false);

            // Array of messages to be displayed randomly in the Info modal
            const aboutMessages = [
                "Nothing good comes from boredom—except maybe this calendar. Too much time, too many pets. I think it's time to feed the cat.",
                "Nothing good comes from boredom—except maybe this calendar. Too much time, too many pets. I think it’s time to consult the guinea pig.",
                "Nothing good comes from boredom—except maybe this calendar. Too much time, too many pets. I think it’s time to follow the dog into the woods.",
                "Nothing good comes from boredom—except maybe this calendar. Too much time, too many pets. I think it's time to let the duck finish what I started."
            ];

            // Select a random message when the modal is opened
            const infoMessage = useMemo(() => {
                const randomIndex = Math.floor(Math.random() * aboutMessages.length);
                return aboutMessages[randomIndex];
            }, [showInfo]);

            const daysTillNewYear = useMemo(() => {
                const today = new Date();
                const newYearDate = new Date(today.getFullYear() + 1, 0, 1);
                return Math.ceil((newYearDate - today) / (1000 * 60 * 60 * 24));
            }, []);

            const hoursTillTomorrow = useMemo(() => {
                const today = new Date();
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(0, 0, 0, 0);
                return Math.floor((tomorrow - today) / (1000 * 60 * 60));
            }, []);
            
            const serviceTypes = [
                { type: 'walk', color: 'bg-[#3FADFB]' },
                { type: 'boarding', color: 'bg-[#C58FFE]' },
                { type: 'drop-in', color: 'bg-[#22C46F]' },
                { type: 'meet-and-greet', color: 'bg-[#FED440]' },
            ];

            const handleDeleteClick = () => {
                onDeleteAllEvents();
                setShowDeleteConfirm(false);
            }

            return (
                <div className="p-4 h-full text-white flex flex-col justify-between">
                    <div className="space-y-3">
                        <div className="border border-gray-500 rounded-full py-4 px-8 flex items-end justify-start text-gray-300">
                            <div className="text-8xl font-thin font-roboto-mono tracking-tighter">{daysTillNewYear}</div>
                            <div className="ml-4 pb-2 text-sm text-gray-400 leading-tight">days till<br/>new year</div>
                        </div>
                        <div className="border border-gray-500 rounded-full py-4 px-8 flex items-end justify-start text-gray-300">
                            <div className="text-8xl font-thin font-roboto-mono tracking-tighter">{String(hoursTillTomorrow).padStart(2, '0')}</div>
                            <div className="ml-4 pb-2 text-sm text-gray-400 leading-tight">hours till<br/>tomorrow</div>
                        </div>
                    </div>

                    <div className="grid grid-cols-2 gap-3">
                        <div className="grid grid-cols-2 gap-3">
                            {serviceTypes.map(({type, color}) => (
                                <button 
                                    key={type} 
                                    onClick={() => onToggleEventType(type)}
                                    className={`w-full aspect-square rounded-full transition-opacity duration-300 ${color} ${hiddenEventTypes.includes(type) ? 'opacity-30' : 'opacity-100'}`}
                                >
                                </button>
                            ))}
                        </div>
                        <div className="flex flex-col gap-3">
                            <button onClick={() => setShowDeleteConfirm(true)} className="flex-1 bg-[#D46E46] rounded-3xl flex items-center justify-center">
                                <Trash size={32} className="text-white"/>
                            </button>
                            <button onClick={() => setShowInfo(true)} className="flex-1 bg-white/10 rounded-3xl flex items-center justify-center">
                                <Info size={32} className="text-gray-300"/>
                            </button>
                        </div>
                    </div>
                    
                    {/* Delete Confirmation Modal */}
                    {showDeleteConfirm && (
                         <div className="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50">
                            <div className="bg-[#2a2a2a] p-6 rounded-2xl text-center w-full max-w-xs">
                                <h3 className="text-lg font-bold text-white mb-2">Are you sure?</h3>
                                <p className="text-gray-300 mb-6">This will permanently delete all events from the calendar.</p>
                                <div className="flex flex-col gap-3">
                                    <button onClick={handleDeleteClick} className="w-full px-4 py-2 font-semibold bg-red-600 hover:bg-red-500 text-white rounded-full">Delete All Events</button>
                                    <button onClick={() => setShowDeleteConfirm(false)} className="w-full px-4 py-2 font-semibold bg-white/10 hover:bg-white/20 text-white rounded-full">Cancel</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Info Modal */}
                    {showInfo && (
                         <div className="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50" onClick={() => setShowInfo(false)}>
                            <div className="bg-[#2a2a2a] p-6 rounded-2xl text-center w-full max-w-xs">
                                <p className="text-gray-200 italic">{infoMessage}</p>
                            </div>
                        </div>
                    )}
                </div>
            );
        };


        const CalendarHeader = ({ currentDate, setCurrentDate, view, onTodayClick, setView, isSorted, setIsSorted }) => {
            const monthName = currentDate.toLocaleString('default', { month: 'long' });
            const year = currentDate.getFullYear();
            const prevMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1));
            const nextMonth = () => setCurrentDate(new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1));

            const getTitle = () => {
                if (view === 'list') return 'List View';
                if (view === 'search') return 'Search';
                if (view === 'insights') return 'Insights';
                if (view === 'settings') return 'Settings';
                return `${monthName} ${year}`;
            };
            
            const handleIconClick = () => {
                if (view !== 'calendar') {
                    setView('calendar');
                }
            };

            return (
                <div className="p-4 bg-[#141414]">
                    <div className="flex items-center justify-between">
                        <div className="flex items-center gap-3 flex-1">
                            <button onClick={handleIconClick} disabled={view === 'calendar'} className={view !== 'calendar' ? 'cursor-pointer' : ''}>
                                <CustomIcon className="w-7 h-7 text-gray-400" />
                            </button>
                            <h1 className="text-xl font-bold text-gray-50">{getTitle()}</h1>
                        </div>
                        <div className="flex items-center justify-end gap-1" style={{minWidth: '100px'}}>
                            {view === 'calendar' && <button onClick={prevMonth} className="p-2 rounded-full hover:bg-white/10 transition-colors"><ChevronLeft className="w-5 h-5 text-gray-300" /></button>}
                            {(view === 'calendar' || view === 'list') && <button onClick={onTodayClick} className="px-3 py-1 text-sm font-semibold text-gray-200 border border-white/20 rounded-full transition-colors active:bg-white/10">Today</button>}
                            {view === 'calendar' && <button onClick={nextMonth} className="p-2 rounded-full hover:bg-white/10 transition-colors"><ChevronRight className="w-5 h-5 text-gray-300" /></button>}
                            {view === 'insights' && (
                                <button onClick={() => setIsSorted(!isSorted)} className="px-3 py-1 text-sm font-semibold text-gray-200 border border-white/20 rounded-full transition-colors active:bg-white/10">
                                    {isSorted ? 'Unsort' : 'Sort'}
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const CalendarGrid = ({ currentDate, events, onDayClick }) => {
            const today = new Date();
            const daysOfWeek = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];

            const calendarDays = useMemo(() => {
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                const firstDayOfMonth = new Date(year, month, 1);
                const lastDayOfMonth = new Date(year, month + 1, 0);
                const startDate = new Date(firstDayOfMonth);
                startDate.setDate(startDate.getDate() - firstDayOfMonth.getDay());
                const endDate = new Date(lastDayOfMonth);
                endDate.setDate(endDate.getDate() + (6 - lastDayOfMonth.getDay()));
                let days = [];
                let day = new Date(startDate);
                while (day <= endDate) {
                    days.push({ date: new Date(day), isCurrentMonth: day.getMonth() === month });
                    day.setDate(day.getDate() + 1);
                }
                return days;
            }, [currentDate]);

            return (
                <div className="flex flex-col flex-grow">
                    <div className="grid grid-cols-7 flex-shrink-0">
                        {daysOfWeek.map((day, index) => <div key={`${day}-${index}`} className="py-2 text-center font-semibold text-xs text-gray-400 border-b border-white/10">{day}</div>)}
                    </div>
                    <div className="grid grid-cols-7 flex-grow" style={{gridTemplateRows: `repeat(${calendarDays.length / 7}, minmax(0, 1fr))`}}>
                        {calendarDays.map(({ date, isCurrentMonth }, index) => {
                            const isToday = isSameDay(date, today);
                            const dayEvents = events.filter(event => {
                                const eventStart = new Date(event.dtstart); eventStart.setHours(0, 0, 0, 0);
                                const eventEnd = new Date(event.dtend);
                                if (!isSameDay(new Date(event.dtstart), new Date(event.dtend)) && eventEnd.getHours() === 0 && eventEnd.getMinutes() === 0) {
                                        eventEnd.setDate(eventEnd.getDate() - 1);
                                }
                                eventEnd.setHours(23, 59, 59, 999);
                                return date >= eventStart && date <= eventEnd;
                            }).sort((a, b) => {
                                const isABoarding = a.type === 'boarding';
                                const isBBoarding = b.type === 'boarding';
                                if (isABoarding && !isBBoarding) return -1;
                                if (!isABoarding && isBBoarding) return 1;
                                return new Date(a.dtstart) - new Date(b.dtstart);
                            });

                            return (
                                <div key={date.toISOString()} className={`p-1 border-b border-white/10 flex flex-col transition-colors cursor-pointer hover:bg-white/10 ${!isCurrentMonth ? 'bg-black/40' : ''} ${ (index + 1) % 7 === 0 ? '' : 'border-r-0' }`} onClick={() => onDayClick(date)}>
                                    <span className={`text-xs font-semibold self-center ${isCurrentMonth ? 'text-gray-100' : 'text-gray-500'} ${isToday ? 'bg-white/20 text-white rounded-full w-6 h-6 flex items-center justify-center' : 'w-6 h-6 flex items-center justify-center'}`}>{date.getDate()}</span>
                                    <div className="mt-1 flex-grow overflow-hidden text-[10px] space-y-1">
                                        {dayEvents.slice(0, 4).map((event) => (
                                            <div key={event.uid} className={`py-px px-1 rounded-md truncate ${getBarColorForEventType(event.type)} text-[#141414] font-medium ${!isCurrentMonth ? 'opacity-40' : ''}`}>{event.summary}</div>
                                        ))}
                                        {dayEvents.length > 4 && <div className="text-gray-400 font-semibold">+ {dayEvents.length - 4} more</div>}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const EventModal = ({ isOpen, onClose, date, events, onEdit, onDelete, onDeleteSeries }) => {
            const [confirmingDelete, setConfirmingDelete] = useState(null);
            if (!isOpen || !date) return null;
            const formatDate = (d) => d.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
            const formatShortDate = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const handleEdit = (event) => { onEdit(event); onClose(); }
            const handleDeleteClick = (event) => {
                if (event.is_recurring) { setConfirmingDelete(event); } 
                else { onDelete(event.uid); onClose(); }
            };
            const confirmSeriesDelete = () => { onDeleteSeries(confirmingDelete.series_id); setConfirmingDelete(null); onClose(); };
            const confirmSingleDelete = () => { onDelete(confirmingDelete.uid); setConfirmingDelete(null); onClose(); };
            
            return (
                <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
                    <div className="bg-[#181818] rounded-2xl shadow-xl w-full max-w-sm max-h-[80vh] flex flex-col">
                        <div className="p-4 border-b border-white/10 flex justify-between items-center">
                            <h2 className="text-lg font-bold text-gray-100">{formatDate(date)}</h2>
                            <button onClick={onClose} className="p-1 rounded-full hover:bg-white/10"><X className="w-5 h-5 text-gray-400" /></button>
                        </div>
                        <div className="p-4 flex-grow overflow-y-auto">
                            {events.length > 0 ? (
                                <div>
                                    {events.map((event, index) => {
                                        const colorClass = getColorForEventType(event.type);
                                        const textColor = colorClass.split(' ')[1];
                                        const dayLabels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                                        const recurringDayNames = event.is_recurring && event.recurring_days ? Object.keys(event.recurring_days).filter(day => event.recurring_days[day]).map(dayIndex => dayLabels[dayIndex]).join(', ') : '';
                                        const hasSelectedDays = recurringDayNames && recurringDayNames.length > 0;

                                        return (
                                        <div key={event.uid}>
                                            <div className="flex justify-between items-start">
                                                <h3 className={`font-semibold ${textColor}`}>{event.summary}</h3>
                                                <span className="text-xs text-gray-400 font-roboto-mono font-normal">{formatEventType(event.type)}</span>
                                            </div>
                                            {event.type === 'boarding' && !isSameDay(new Date(event.dtstart), new Date(event.dtend)) ? (
                                                <div className="text-sm text-gray-300 mt-2 space-y-1">
                                                    <p>{formatShortDate(new Date(event.dtstart))} to {formatShortDate(new Date(event.dtend))}</p>
                                                    <p>Drop-off: {formatTime(new Date(event.dtstart))} &nbsp;|&nbsp; Pick-up: {formatTime(new Date(event.dtend))}</p>
                                                </div>
                                            ) : (
                                                <p className="text-sm text-gray-300 mt-1">{formatTime(new Date(event.dtstart))} - {formatTime(new Date(event.dtend))}</p>
                                            )}
                                            {event.is_recurring && (
                                                <p className="text-xs text-gray-400 mt-1">
                                                    {hasSelectedDays
                                                        ? `Every ${recurringDayNames}`
                                                        : event.series_start_date && event.recur_until
                                                            ? `${formatShortDate(new Date(event.series_start_date))} to ${formatShortDate(new Date(event.recur_until))}`
                                                            : 'Recurring Event'
                                                    }
                                                </p>
                                            )}
                                            {event.description && <p className="text-xs text-gray-400 mt-2 whitespace-pre-wrap">{event.description}</p>}
                                            <div className="flex gap-2 mt-3">
                                                <button onClick={() => handleEdit(event)} className="px-4 py-2 bg-white/10 hover:bg-white/20 text-gray-200 rounded-full"><Edit size={14}/></button>
                                                <button onClick={() => handleDeleteClick(event)} className="px-4 py-2 bg-red-500/20 hover:bg-red-500/30 text-red-200 rounded-full"><Trash2 size={14}/></button>
                                            </div>
                                            {index < events.length - 1 && <hr className="border-t border-gray-700 my-4" />}
                                        </div>
                                    )})}
                                </div>
                            ) : <p className="text-center text-gray-500 py-8">No events scheduled.</p>}
                        </div>
                    </div>
                    {confirmingDelete && (
                        <div className="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4">
                            <div className="bg-[#2a2a2a] p-4 rounded-2xl text-center">
                                <p className="text-gray-200 mb-4">This is a recurring event. Do you want to remove only this one, or the entire series?</p>
                                <div className="flex flex-col gap-2">
                                    <button onClick={confirmSingleDelete} className="w-full px-4 py-2 text-sm bg-red-600 hover:bg-red-500 text-white rounded-full">Remove just this event</button>
                                    <button onClick={confirmSeriesDelete} className="w-full px-4 py-2 text-sm bg-red-700 hover:bg-red-600 text-white rounded-full">Remove all in series</button>
                                    <button onClick={() => setConfirmingDelete(null)} className="w-full px-4 py-2 text-sm bg-white/10 hover:bg-white/20 text-white rounded-full mt-2">Cancel</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const AddEventForm = ({ isOpen, onAddEvents, eventToEdit, onUpdateEvent, onUpdateSeries, onCancelEdit, isLocalOrPreview }) => {
            const [name, setName] = useState('');
            const [type, setType] = useState('walk');
            const [date, setDate] = useState(formatDateToYYYYMMDD(new Date()));
            const [time, setTime] = useState('09:00');
            const [duration, setDuration] = useState(30);
            const [description, setDescription] = useState('');
            const [isRecurring, setIsRecurring] = useState(false);
            const [recurringDays, setRecurringDays] = useState({ 0: false, 1: false, 2: false, 3: false, 4: false, 5: false, 6: false });
            const [recurUntil, setRecurUntil] = useState(formatDateToYYYYMMDD(new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)));
            const [startDate, setStartDate] = useState(formatDateToYYYYMMDD(new Date()));
            const [endDate, setEndDate] = useState(formatDateToYYYYMMDD(new Date(Date.now() + 3 * 24 * 60 * 60 * 1000)));
            const [dropOffTime, setDropOffTime] = useState('09:00');
            const [pickUpTime, setPickUpTime] = useState('17:00');
            const [updateScope, setUpdateScope] = useState('single');
            const isEditMode = !!eventToEdit;

            // --- Autocomplete state and handler ---
            const [petNameSuggestions, setPetNameSuggestions] = useState([]);
            const inputRef = useRef(null);
            
            const handleNameChange = async (e) => {
                const newName = e.target.value;
                setName(newName);

                if (isLocalOrPreview) {
                    setPetNameSuggestions([]);
                    return;
                }
                
                if (newName.length > 1) {
                    try {
                        const response = await fetch(`/.netlify/functions/getPetNames?q=${encodeURIComponent(newName)}`);
                        if (response.ok) {
                            const suggestions = await response.json();
                            setPetNameSuggestions(suggestions);
                        } else {
                            setPetNameSuggestions([]);
                        }
                    } catch (error) {
                        console.error("Failed to fetch pet name suggestions:", error);
                        setPetNameSuggestions([]);
                    }
                } else {
                    setPetNameSuggestions([]);
                }
            };
            
            const handleSuggestionClick = (suggestion) => {
                setName(suggestion);
                setPetNameSuggestions([]);
            };

            useEffect(() => {
                if (eventToEdit) {
                    const start = new Date(eventToEdit.dtstart);
                    const end = new Date(eventToEdit.dtend);

                    setName(eventToEdit.summary);
                    setType(eventToEdit.type);
                    setDescription(eventToEdit.description || '');
                    
                    if (eventToEdit.type === 'boarding') {
                        setStartDate(formatDateToYYYYMMDD(start));
                        setDropOffTime(`${start.getHours().toString().padStart(2, '0')}:${start.getMinutes().toString().padStart(2, '0')}`);
                        setEndDate(formatDateToYYYYMMDD(end));
                        setPickUpTime(`${end.getHours().toString().padStart(2, '0')}:${end.getMinutes().toString().padStart(2, '0')}`);
                    } else {
                        setDate(formatDateToYYYYMMDD(start));
                        setTime(`${start.getHours().toString().padStart(2, '0')}:${start.getMinutes().toString().padStart(2, '0')}`);
                        const durationMinutes = (end - start) / 60000;
                        setDuration(durationMinutes);
                    }

                    setIsRecurring(eventToEdit.is_recurring || false);
                    setRecurringDays(eventToEdit.recurring_days || { 0: false, 1: false, 2: false, 3: false, 4: false, 5: false, 6: false });
                    
                    if (eventToEdit.is_recurring && eventToEdit.recur_until) {
                        const recurUntilDate = new Date(eventToEdit.recur_until);
                        const timezoneCorrectedDate = new Date(recurUntilDate.getUTCFullYear(), recurUntilDate.getUTCMonth(), recurUntilDate.getUTCDate());
                        setRecurUntil(formatDateToYYYYMMDD(timezoneCorrectedDate));
                    } else {
                        const defaultRecurDate = new Date();
                        defaultRecurDate.setDate(defaultRecurDate.getDate() + 7);
                        setRecurUntil(formatDateToYYYYMMDD(defaultRecurDate));
                    }
                } else { 
                    resetForm(); 
                }
            }, [eventToEdit]);

            const timeOptions = useMemo(() => {
                const options = [];
                for (let h = 0; h < 24; h++) {
                    options.push(`${h.toString().padStart(2, '0')}:00`);
                    options.push(`${h.toString().padStart(2, '0')}:30`);
                }
                return options;
            }, []);

            const handleRecurringDayToggle = (dayIndex) => setRecurringDays(prev => ({ ...prev, [dayIndex]: !prev[dayIndex] }));
            const resetForm = () => { setName(''); setDescription(''); setIsRecurring(false); setRecurringDays({ 0: false, 1: false, 2: false, 3: false, 4: false, 5: false, 6: false }); onCancelEdit(); setPetNameSuggestions([]); }

            const handleSubmit = (e) => {
                e.preventDefault();
                if (!name) return;

                // --- EDIT LOGIC ---
                if (isEditMode) {
                    // Handle update for the entire series
                    if (eventToEdit.is_recurring && updateScope === 'series') {
                        const updatedSeriesData = { 
                            name, 
                            time, 
                            duration, 
                            recurring_days: recurringDays, 
                            recur_until: recurUntil, 
                            description,
                            series_start_date: eventToEdit.series_start_date
                        };
                        onUpdateSeries(eventToEdit, { ...updatedSeriesData, type: eventToEdit.type });
                        resetForm();
                        return;
                    }
                    
                    // Handle update for a single instance or a non-recurring event
                    let updatedEvent = { ...eventToEdit, summary: name, type, description };
                    
                    if (type === 'boarding') {
                        updatedEvent.dtstart = parseDateTime(startDate, dropOffTime).toISOString();
                        updatedEvent.dtend = parseDateTime(endDate, pickUpTime).toISOString();
                    } else {
                        const eventStart = parseDateTime(date, time);
                        const finalDuration = type === 'meet-and-greet' ? 30 : duration;
                        const eventEnd = new Date(eventStart.getTime() + finalDuration * 60000);
                        updatedEvent.dtstart = eventStart.toISOString();
                        updatedEvent.dtend = eventEnd.toISOString();
                        
                        if (eventToEdit.is_recurring) {
                            updatedEvent.is_recurring = false;
                            delete updatedEvent.series_id;
                            delete updatedEvent.recurring_days;
                            delete updatedEvent.recur_until;
                            delete updatedEvent.series_start_date;
                        }
                    }
                    onUpdateEvent(updatedEvent);
                    resetForm();
                    return;
                }

                // --- ADD LOGIC ---
                let newEvents = [];
                if (type === 'boarding') {
                    const start = parseDateTime(startDate, dropOffTime);
                    const end = parseDateTime(endDate, pickUpTime);
                    newEvents.push({ summary: name, dtstart: start.toISOString(), dtend: end.toISOString(), type, description, uid: `manual-${crypto.randomUUID()}` });
                } else if (isRecurring && (type === 'walk' || type === 'drop-in')) {
                    let selectedDays = Object.keys(recurringDays).filter(day => recurringDays[day]).map(Number);
                    const hasSelectedDays = selectedDays.length > 0;
                    if (!hasSelectedDays) {
                        selectedDays = [0, 1, 2, 3, 4, 5, 6]; // Default to daily
                    }
                    const series_start_date = date;
                    let currentDate = parseDateTime(date);
                    const untilDate = parseDateTime(recurUntil, '23:59');
                    const series_id = `manual-series-${crypto.randomUUID()}`;
                    while (currentDate <= untilDate) {
                        if (selectedDays.includes(currentDate.getDay())) {
                            const eventStart = parseDateTime(formatDateToYYYYMMDD(currentDate), time);
                            const eventEnd = new Date(eventStart.getTime() + duration * 60000);
                            newEvents.push({ summary: name, dtstart: eventStart.toISOString(), dtend: eventEnd.toISOString(), type, description, uid: `manual-${crypto.randomUUID()}`, is_recurring: true, recurring_days: hasSelectedDays ? recurringDays : null, series_id, recur_until: recurUntil, series_start_date });
                        }
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                } else {
                    const eventStart = parseDateTime(date, time);
                    const finalDuration = type === 'meet-and-greet' ? 30 : duration;
                    const eventEnd = new Date(eventStart.getTime() + finalDuration * 60000);
                    newEvents.push({ summary: name, dtstart: eventStart.toISOString(), dtend: eventEnd.toISOString(), type, description, uid: `manual-${crypto.randomUUID()}` });
                }
                if (newEvents.length > 0) { onAddEvents(newEvents); resetForm(); }
            };

            const dayLabels = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
            const inputClasses = "w-full px-4 py-2 text-sm bg-white/5 border border-white/10 text-white rounded-full focus:outline-none focus:ring-2 focus:ring-white/20";
            const textareaClasses = "w-full px-4 py-2 text-sm bg-white/5 border border-white/10 text-white rounded-2xl focus:outline-none focus:ring-2 focus:ring-white/20";
            const dateInputClasses = `${inputClasses} dark-date-input`;
            const selectClasses = `${inputClasses} custom-select`;

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
                    <div className="bg-[#1F1F1F] rounded-2xl shadow-xl w-full max-w-sm max-h-[90vh] flex flex-col">
                        <div className="p-4 border-b border-white/10 flex justify-between items-center">
                            <h3 className="text-lg font-semibold text-gray-100 flex items-center gap-2"><PlusCircle className="w-6 h-6 text-gray-400" />{isEditMode ? 'Edit Event' : 'Add Event'}</h3>
                            <button onClick={onCancelEdit} className="p-1 rounded-full hover:bg-white/10"><X className="w-5 h-5 text-gray-400" /></button>
                        </div>
                        <div className="p-4 overflow-y-auto">
                            <style>{`
                                .dark-date-input { color-scheme: dark; } 
                                .dark-date-input::-webkit-calendar-picker-indicator { filter: invert(1); } 
                                .custom-select { 
                                    -webkit-appearance: none; 
                                    -moz-appearance: none; 
                                    appearance: none; 
                                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%239ca3af'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd' /%3E%3C/svg%3E"); 
                                    background-repeat: no-repeat; 
                                    background-position: right 0.5rem center; 
                                    background-size: 1.5em 1.5em;
                                }
                                .custom-select {
                                    background-color: rgba(255, 255, 255, 0.05);
                                }
                                select option {
                                    background: #1F1F1F; /* Match modal background color for a dark theme */
                                    color: white;
                                }
                                /* Add new styles for the suggestions list */
                                .autocomplete-container {
                                    position: relative;
                                }
                                .suggestions-list {
                                    position: absolute;
                                    top: 100%;
                                    left: 0;
                                    right: 0;
                                    background-color: #1F1F1F;
                                    border: 1px solid #333;
                                    border-top: none;
                                    border-radius: 0 0 0.5rem 0.5rem;
                                    z-index: 10;
                                    max-height: 150px;
                                    overflow-y: auto;
                                    list-style: none;
                                    padding: 0;
                                    margin: 0;
                                }
                                .suggestions-list li {
                                    padding: 0.75rem 1rem;
                                    cursor: pointer;
                                    color: #ccc;
                                }
                                .suggestions-list li:hover {
                                    background-color: #333;
                                }
                            `}</style>
                            <form onSubmit={handleSubmit} className="space-y-4">
                                <div className="autocomplete-container">
                                    <input 
                                        type="text" 
                                        value={name} 
                                        onChange={handleNameChange}
                                        onBlur={() => setTimeout(() => setPetNameSuggestions([]), 200)}
                                        placeholder="Pet's Name" 
                                        className={inputClasses} 
                                        required 
                                        ref={inputRef}
                                    />
                                    {petNameSuggestions.length > 0 && (
                                        <ul className="suggestions-list">
                                            {petNameSuggestions.map((suggestion, index) => (
                                                <li key={index} onMouseDown={() => handleSuggestionClick(suggestion)}>
                                                    {suggestion}
                                                </li>
                                            ))}
                                        </ul>
                                    )}
                                </div>
                                <div>
                                    <label className="text-xs text-gray-400 block mb-1 px-4">Service Type</label>
                                    <select value={type} onChange={e => setType(e.target.value)} className={selectClasses} disabled={isEditMode && eventToEdit.is_recurring && updateScope === 'series'}>
                                        <option value="walk">Walk</option><option value="drop-in">Drop-in</option>
                                        <option value="boarding">Boarding</option><option value="meet-and-greet">Meet & Greet</option>
                                    </select>
                                </div>
                                {isEditMode && eventToEdit.is_recurring && (
                                    <div className="text-sm text-gray-400 p-3 bg-black/30 rounded-2xl space-y-2">
                                        <p className="font-semibold text-center">Edit Recurring Event</p>
                                        <div className="flex justify-around">
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input type="radio" name="updateScope" value="single" checked={updateScope === 'single'} onChange={() => setUpdateScope('single')} className="hidden" />
                                                <div className={`w-5 h-5 border-2 ${updateScope === 'single' ? 'border-gray-400' : 'border-gray-500'} rounded-full flex items-center justify-center`}>{updateScope === 'single' && <div className="w-2.5 h-2.5 bg-gray-400 rounded-full"></div>}</div>
                                                This event only
                                            </label>
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input type="radio" name="updateScope" value="series" checked={updateScope === 'series'} onChange={() => setUpdateScope('series')} className="hidden" />
                                                <div className={`w-5 h-5 border-2 ${updateScope === 'series' ? 'border-gray-400' : 'border-gray-500'} rounded-full flex items-center justify-center`}>{updateScope === 'series' && <div className="w-2.5 h-2.5 bg-gray-400 rounded-full"></div>}</div>
                                                Entire series
                                            </label>
                                        </div>
                                    </div>
                                )}
                                {type === 'boarding' ? (
                                    <div className="space-y-3 p-3 bg-black/30 rounded-2xl">
                                        <div className="flex gap-2">
                                            <div className="flex-1"><label className="text-xs text-gray-400 block mb-1 px-4">Start Date</label><input type="date" value={startDate} onChange={e => setStartDate(e.target.value)} className={dateInputClasses} required /></div>
                                            <div className="flex-1"><label className="text-xs text-gray-400 block mb-1 px-4">Drop-off</label><select value={dropOffTime} onChange={e => setDropOffTime(e.target.value)} className={selectClasses}>{timeOptions.map(t => <option key={t} value={t}>{t}</option>)}</select></div>
                                        </div>
                                        <div className="flex gap-2">
                                            <div className="flex-1"><label className="text-xs text-gray-400 block mb-1 px-4">End Date</label><input type="date" value={endDate} onChange={e => setEndDate(e.target.value)} className={dateInputClasses} required /></div>
                                            <div className="flex-1"><label className="text-xs text-gray-400 block mb-1 px-4">Pick-up</label><select value={pickUpTime} onChange={e => setPickUpTime(e.target.value)} className={selectClasses}>{timeOptions.map(t => <option key={t} value={t}>{t}</option>)}</select></div>
                                        </div>
                                    </div>
                                ) : (
                                    <div className="space-y-3 p-3 bg-black/30 rounded-2xl">
                                        <div className="flex gap-2">
                                            <div className="flex-1"><label className="text-xs text-gray-400 block mb-1 px-4">Date</label><input type="date" value={date} onChange={e => setDate(e.target.value)} className={dateInputClasses} required /></div>
                                            <div className="flex-1"><label className="text-xs text-gray-400 block mb-1 px-4">Time</label><select value={time} onChange={e => setTime(e.target.value)} className={selectClasses}>{timeOptions.map(t => <option key={t} value={t}>{t}</option>)}</select></div>
                                        </div>
                                        {type !== 'meet-and-greet' && (<div><label className="text-xs text-gray-400 block mb-1 px-4">Duration</label><select value={duration} onChange={e => setDuration(Number(e.target.value))} className={selectClasses}><option value={30}>30 minutes</option><option value={60}>1 hour</option></select></div>)}
                                        {((type === 'walk' || type === 'drop-in') && (!isEditMode || (isEditMode && updateScope === 'series'))) && <div className="flex items-center gap-2 px-4"><label htmlFor="is-recurring" className="flex items-center gap-2 text-sm text-gray-300 cursor-pointer"><div className="w-5 h-5 border-2 border-gray-500 rounded-full flex items-center justify-center">{isRecurring && <div className="w-2.5 h-2.5 bg-gray-400 rounded-full"></div>}</div>Recurring Event</label><input type="checkbox" id="is-recurring" checked={isRecurring} onChange={e => setIsRecurring(e.target.checked)} className="hidden" disabled={isEditMode && updateScope === 'single'}/></div>}
                                        {((isRecurring && (type === 'walk' || type === 'drop-in')) && (!isEditMode || (isEditMode && updateScope === 'series'))) && (
                                            <div className="space-y-2">
                                                <div><label className="text-xs text-gray-400 block mb-1 px-4">Repeat on</label><div className="flex justify-between gap-1">{dayLabels.map((label, index) => <button type="button" key={index} onClick={() => handleRecurringDayToggle(index)} className={`w-8 h-8 rounded-full text-xs font-bold transition-colors ${recurringDays[index] ? 'bg-white/20 text-white' : 'bg-white/5 hover:bg-white/10 text-gray-200'}`}>{label}</button>)}</div></div>
                                                <div><label className="text-xs text-gray-400 block mb-1 px-4">Recur Until</label><input type="date" value={recurUntil} onChange={e => setRecurUntil(e.target.value)} className={dateInputClasses} required /></div>
                                            </div>
                                        )}
                                    </div>
                                )}
                                <textarea value={description} onChange={e => setDescription(e.target.value)} placeholder="Optional Notes..." className={textareaClasses} rows="3"></textarea>
                                <div className="flex gap-2 pt-2">
                                    {isEditMode && <button type="button" onClick={onCancelEdit} className="w-full px-4 py-2 font-semibold text-white bg-white/10 rounded-full hover:bg-white/20 transition-colors">Cancel</button>}
                                    <button type="submit" className="w-full px-4 py-2 font-semibold text-black bg-gray-200 rounded-full hover:bg-white transition-colors">{isEditMode ? 'Update Event' : 'Add Event'}</button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [isAuthenticated, setIsAuthenticated] = useState(false);
            const [currentDate, setCurrentDate] = useState(new Date()); // Start view in current month
            const [events, setEvents] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [error, setError] = useState(null);
            const [selectedDay, setSelectedDay] = useState({ date: null });
            const [isDayModalOpen, setIsDayModalOpen] = useState(false);
            const [isAddModalOpen, setIsAddModalOpen] = useState(false);
            const [editingEvent, setEditingEvent] = useState(null);
            const [view, setView] = useState('calendar'); // 'calendar', 'list', 'search', 'insights', 'settings'
            const [searchQuery, setSearchQuery] = useState('');
            const [selectedService, setSelectedService] = useState(null);
            const [hiddenEventTypes, setHiddenEventTypes] = useState([]);
            const [isSorted, setIsSorted] = useState(false); // State for sorting on the Insights page
            const contentRef = useRef(null);
            const todayDateString = new Date().toDateString();
            
            // The base URL for your Netlify Functions
            const API_ENDPOINT = '/.netlify/functions/events';
            // A simple check to see if we're in a local/preview environment vs deployed on Netlify
            const isLocalOrPreview = !window.location.hostname || window.location.hostname === 'localhost';

            // Check for authentication on initial load
            useEffect(() => {
                if (sessionStorage.getItem('pet-calendar-auth') === 'true') {
                    setIsAuthenticated(true);
                }
            }, []);

            // Function to fetch all events from the backend
            const fetchEvents = async () => {
                setIsLoading(true);
                setError(null);

                // If in a local preview, use mock data to avoid fetch errors
                if (isLocalOrPreview) {
                    console.log("Running in local/preview mode. Using mock data.");
                    const year = 2025;
                    const may = 4;
                    const july = 6;
                    const august = 7;
                    const mockData = [
                        // May Events
                        { uid: 'mock-1', summary: "Milo", dtstart: new Date(year, may, 5, 10, 0, 0), dtend: new Date(year, may, 5, 10, 30, 0), type: 'walk' },
                        { uid: 'mock-2', summary: "Daisy", dtstart: new Date(year, may, 10, 12, 0, 0), dtend: new Date(year, may, 10, 12, 30, 0), type: 'drop-in' },
                        { uid: 'mock-3', summary: "Rocky", dtstart: new Date(year, may, 15, 9, 0, 0), dtend: new Date(year, may, 18, 17, 0, 0), type: 'boarding' },
                        { uid: 'mock-4', summary: "Bella", dtstart: new Date(year, may, 20, 16, 0, 0), dtend: new Date(year, may, 20, 17, 0, 0), type: 'walk' },
                        { uid: 'mock-5', summary: "Charlie", dtstart: new Date(year, may, 25, 11, 0, 0), dtend: new Date(year, may, 25, 11, 30, 0), type: 'meet-and-greet' },
                        { uid: 'mock-6', summary: "Lucy", dtstart: new Date(year, may, 30, 14, 0, 0), dtend: new Date(year, may, 30, 14, 30, 0), type: 'drop-in' },

                        // July Events
                        { uid: 'mock-7', summary: "Max", dtstart: new Date(year, july, 1, 8, 0, 0), dtend: new Date(year, july, 1, 8, 30, 0), type: 'walk' },
                        { uid: 'mock-8', summary: "Buddy", dtstart: new Date(year, july, 5, 13, 0, 0), dtend: new Date(year, july, 5, 13, 30, 0), type: 'drop-in' },
                        { uid: 'mock-9', summary: "Sadie", dtstart: new Date(year, july, 10, 18, 0, 0), dtend: new Date(year, july, 15, 10, 0, 0), type: 'boarding' },
                        { uid: 'mock-10', summary: "Cooper", dtstart: new Date(year, july, 18, 9, 30, 0), dtend: new Date(year, july, 18, 10, 0, 0), type: 'walk' },
                        { uid: 'mock-11', summary: "Zoe", dtstart: new Date(year, july, 22, 17, 0, 0), dtend: new Date(year, july, 22, 17, 30, 0), type: 'meet-and-greet' },
                        { uid: 'mock-12', summary: "Toby", dtstart: new Date(year, july, 28, 11, 30, 0), dtend: new Date(year, july, 28, 12, 0, 0), type: 'drop-in' },
                        { uid: 'mock-13', summary: "Molly", dtstart: new Date(year, july, 30, 7, 0, 0), dtend: new Date(year, july, 30, 8, 0, 0), type: 'walk' },
                        { uid: 'mock-14', summary: "Lucy", dtstart: new Date(year, july, 2, 9, 0, 0), dtend: new Date(year, july, 2, 9, 30, 0), type: 'walk' },
                        { uid: 'mock-15', summary: "Luna", dtstart: new Date(year, july, 26, 9, 0, 0), dtend: new Date(year, july, 28, 17, 0, 0), type: 'boarding' },

                        // August Events
                        { uid: 'mock-16', summary: "Oscar", dtstart: new Date(year, august, 2, 15, 0, 0), dtend: new Date(year, august, 2, 15, 30, 0), type: 'walk' },
                        { uid: 'mock-17', summary: "Ruby", dtstart: new Date(year, august, 6, 10, 0, 0), dtend: new Date(year, august, 6, 10, 30, 0), type: 'drop-in' },
                        { uid: 'mock-18', summary: "Leo", dtstart: new Date(year, august, 12, 8, 0, 0), dtend: new Date(year, august, 16, 19, 0, 0), type: 'boarding' },
                        { uid: 'mock-19', summary: "Jack", dtstart: new Date(year, august, 19, 16, 30, 0), dtend: new Date(year, august, 19, 17, 0, 0), type: 'walk' },
                        { uid: 'mock-20', summary: "Penny", dtstart: new Date(year, august, 23, 18, 0, 0), dtend: new Date(year, august, 23, 18, 30, 0), type: 'meet-and-greet' },
                        { uid: 'mock-21', summary: "Gus", dtstart: new Date(year, august, 27, 9, 0, 0), dtend: new Date(year, august, 27, 9, 30, 0), type: 'drop-in' },
                        { uid: 'mock-22', summary: "Nala", dtstart: new Date(year, august, 31, 12, 0, 0), dtend: new Date(year, august, 31, 13, 0, 0), type: 'walk' },
                    ];
                    setEvents(mockData);
                    setIsLoading(false);
                    return;
                }

                try {
                    const response = await fetch(API_ENDPOINT);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    // Convert date strings from backend into Date objects
                    const processedEvents = data.map(event => ({
                        ...event,
                        dtstart: new Date(event.dtstart),
                        dtend: new Date(event.dtend),
                    }));
                    setEvents(processedEvents);
                } catch (e) {
                    console.error("Failed to fetch events:", e);
                    setError("Could not load calendar data. Please try again later.");
                } finally {
                    setIsLoading(false);
                }
            };

            // Fetch events only when authenticated
            useEffect(() => {
                if (isAuthenticated) {
                    fetchEvents();
                }
            }, [isAuthenticated]);
            
            // Effect to scroll to today's date when switching to list view
            useEffect(() => {
                if (view === 'list') {
                    setTimeout(() => {
                        const todayElement = document.getElementById('today-marker');
                        if (todayElement) {
                            todayElement.scrollIntoView({ behavior: 'auto', block: 'start' });
                        }
                    }, 100); // Small delay to ensure DOM is updated
                }
            }, [view]);

            const handleLogin = () => {
                sessionStorage.setItem('pet-calendar-auth', 'true');
                setIsAuthenticated(true);
            };

            const handleTodayClick = () => {
                if (view === 'calendar') {
                    setCurrentDate(new Date());
                } else { // For 'list' or 'search' view
                    const todayElement = document.getElementById('today-marker');
                    if (todayElement) {
                        todayElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }
            };

            const handleAddEvents = async (newEvents) => {
                if (isLocalOrPreview) {
                    console.log("Local mode: Adding events to state.", newEvents);
                    const eventsWithDates = newEvents.map(e => ({...e, dtstart: new Date(e.dtstart), dtend: new Date(e.dtend)}));
                    setEvents(prev => [...prev, ...eventsWithDates]);
                    setIsAddModalOpen(false);
                    return;
                }
                try {
                    const response = await fetch(API_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newEvents),
                    });
                    if (!response.ok) throw new Error('Failed to add events');
                    await fetchEvents(); // Refetch all events to get the new ones with DB-generated IDs
                    setIsAddModalOpen(false);
                } catch (e) {
                    console.error("Error adding events:", e);
                    setError("Failed to save new events.");
                }
            };

            const handleDayClick = (date) => { setSelectedDay({ date, singleEvent: null }); setIsDayModalOpen(true); };
            const handleEventClick = (event, date) => {
                setSelectedDay({ date, singleEvent: event });
                setIsDayModalOpen(true);
            };
            const handleCloseModal = () => { setSelectedDay({ date: null, singleEvent: null }); setIsDayModalOpen(false); };
            
            const handleEditEvent = (event) => { setEditingEvent(event); setIsAddModalOpen(true); };
            const handleCancelEdit = () => { setEditingEvent(null); setIsAddModalOpen(false); };
            
            const handleUpdateEvent = async (updatedEvent) => {
                 if (isLocalOrPreview) {
                    console.log("Local mode: Updating event.", updatedEvent);
                    setEvents(events.map(e => e.uid === updatedEvent.uid ? {...updatedEvent, dtstart: new Date(updatedEvent.dtstart), dtend: new Date(updatedEvent.dtend)} : e));
                    setEditingEvent(null);
                    setIsAddModalOpen(false);
                    return;
                }
                try {
                    const response = await fetch(`${API_ENDPOINT}?uid=${updatedEvent.uid}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updatedEvent),
                    });
                    if (!response.ok) throw new Error('Failed to update event');
                    await fetchEvents(); // Refetch to update the UI
                    setEditingEvent(null);
                    setIsAddModalOpen(false);
                } catch (e) {
                    console.error("Error updating event:", e);
                    setError("Failed to update event.");
                }
            };

            const handleDeleteEvent = async (uidToDelete) => {
                if (isLocalOrPreview) {
                    console.log("Local mode: Deleting event.", uidToDelete);
                    setEvents(events.filter(e => e.uid !== uidToDelete));
                    return;
                }
                try {
                    const response = await fetch(`${API_ENDPOINT}?uid=${uidToDelete}`, {
                        method: 'DELETE',
                    });
                    if (!response.ok) throw new Error('Failed to delete event');
                    setEvents(events.filter(e => e.uid !== uidToDelete)); // Optimistic update
                } catch (e) {
                    console.error("Error deleting event:", e);
                    setError("Failed to delete event.");
                    fetchEvents(); // Refetch to correct UI if delete failed
                }
            };

            const handleDeleteSeries = async (seriesIdToDelete) => {
                if (isLocalOrPreview) {
                    console.log("Local mode: Deleting series.", seriesIdToDelete);
                    setEvents(events.filter(e => e.series_id !== seriesIdToDelete));
                    return;
                }
                try {
                    const response = await fetch(`${API_ENDPOINT}?seriesId=${seriesIdToDelete}`, {
                        method: 'DELETE',
                    });
                     if (!response.ok) throw new Error('Failed to delete series');
                    setEvents(events.filter(e => e.series_id !== seriesIdToDelete)); // Optimistic update
                } catch (e) {
                    console.error("Error deleting series:", e);
                    setError("Failed to delete event series.");
                    fetchEvents(); // Refetch to correct UI
                }
            };

            const handleUpdateSeries = async (editedEvent, updatedData) => {
                if (isLocalOrPreview) {
                    console.log("Local mode: Updating series in state.", updatedData);

                    // Remove all old events from this series
                    const otherEvents = events.filter(e => e.series_id !== editedEvent.series_id);

                    // Generate new events based on updatedData
                    let newSeriesEvents = [];
                    const { name, time, duration, recurring_days, recur_until, description, type, series_start_date } = updatedData;
                    
                    let selectedDays = Object.keys(recurring_days).filter(day => recurring_days[day]).map(Number);
                    if (selectedDays.length === 0) {
                        selectedDays = [0, 1, 2, 3, 4, 5, 6];
                    }

                    let currentDate = parseDateTime(series_start_date);
                    const untilDate = parseDateTime(recur_until, '23:59');
                    const series_id = editedEvent.series_id; // Reuse the same series_id

                    while (currentDate <= untilDate) {
                        if (selectedDays.includes(currentDate.getDay())) {
                            const eventStart = parseDateTime(formatDateToYYYYMMDD(currentDate), time);
                            const eventEnd = new Date(eventStart.getTime() + duration * 60000);
                            newSeriesEvents.push({
                                summary: name,
                                dtstart: eventStart,
                                dtend: eventEnd,
                                type,
                                description,
                                uid: `manual-${crypto.randomUUID()}`,
                                is_recurring: true,
                                recurring_days: recurring_days,
                                series_id,
                                recur_until,
                                series_start_date
                            });
                        }
                        currentDate.setDate(currentDate.getDate() + 1);
                    }

                    // Update the state with the other events plus the new series events
                    setEvents([...otherEvents, ...newSeriesEvents]);
                    
                    setEditingEvent(null);
                    setIsAddModalOpen(false);
                    return;
                }

                 try {
                    const response = await fetch(`${API_ENDPOINT}?seriesId=${editedEvent.series_id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ...updatedData, type: editedEvent.type }),
                    });
                    if (!response.ok) throw new Error('Failed to update series');
                    await fetchEvents();
                    setEditingEvent(null);
                    setIsAddModalOpen(false);
                } catch (e) {
                    console.error("Error updating series:", e);
                    setError("Failed to update event series.");
                }
            };
            
            const handleDeleteAllEvents = async () => {
                if (isLocalOrPreview) {
                    console.log("Local mode: Deleting all events.");
                    setEvents([]);
                    return;
                }
                try {
                    const response = await fetch(`${API_ENDPOINT}?deleteAll=true`, {
                        method: 'DELETE',
                    });
                    if (!response.ok) throw new Error('Failed to delete all events');
                    setEvents([]); // Optimistic update
                } catch (e) {
                    console.error("Error deleting all events:", e);
                    setError("Failed to delete all events.");
                    fetchEvents(); // Refetch to correct UI
                }
            };
            
            const handleToggleEventType = (typeToToggle) => {
                setHiddenEventTypes(prev => 
                    prev.includes(typeToToggle) 
                    ? prev.filter(t => t !== typeToToggle)
                    : [...prev, typeToToggle]
                );
            };

            const calendarVisibleEvents = useMemo(() => {
                return events.filter(event => !hiddenEventTypes.includes(event.type));
            }, [events, hiddenEventTypes]);

            const modalEvents = useMemo(() => {
                if (!selectedDay.date) return [];
                
                const dayEvents = events.filter(event => {
                    const eventStart = new Date(event.dtstart); eventStart.setHours(0,0,0,0);
                    const eventEnd = new Date(event.dtend);
                    const isSameStartEndDay = isSameDay(new Date(event.dtstart), new Date(event.dtend));
                    if (!isSameStartEndDay && eventEnd.getHours() === 0 && eventEnd.getMinutes() === 0) {
                        eventEnd.setDate(eventEnd.getDate() - 1);
                    }
                    eventEnd.setHours(23,59,59,999);
                    return selectedDay.date >= eventStart && selectedDay.date <= eventEnd;
                }).sort((a, b) => {
                    const isABoarding = a.type === 'boarding';
                    const isBBoarding = b.type === 'boarding';
                    if (isABoarding && !isBBoarding) return -1;
                    if (!isABoarding && isBBoarding) return 1;
                    return new Date(a.dtstart) - new Date(b.dtstart);
                });

                if (selectedDay.singleEvent) {
                    return [selectedDay.singleEvent];
                }
                return dayEvents;

            }, [selectedDay, events]);

            const sortedEvents = useMemo(() => [...events].sort((a,b) => new Date(a.dtstart) - new Date(b.dtstart)), [events]);

            const filteredEvents = useMemo(() => {
                if (!searchQuery && !selectedService) {
                    return [];
                }

                let eventsToFilter = sortedEvents;

                if (searchQuery) {
                    const lowerCaseQuery = searchQuery.toLowerCase();
                    return eventsToFilter.filter(event => 
                        event.summary.toLowerCase().includes(lowerCaseQuery) ||
                        event.type.replace('-', ' ').toLowerCase().includes(lowerCaseQuery)
                    );
                }

                if (selectedService) {
                    return eventsToFilter.filter(event => event.type === selectedService);
                }
                
                return [];
            }, [searchQuery, selectedService, sortedEvents]);

            const groupEvents = (sourceEvents) => {
                const groups = {};
                sourceEvents.forEach(event => {
                    const startDate = new Date(event.dtstart); startDate.setHours(0,0,0,0);
                    const endDate = new Date(event.dtend); endDate.setHours(0,0,0,0);
                    if (!isSameDay(new Date(event.dtstart), new Date(event.dtend)) && new Date(event.dtend).getHours() === 0 && new Date(event.dtend).getMinutes() === 0) {
                        endDate.setDate(endDate.getDate() - 1);
                    }
                    let currentDate = new Date(startDate);
                    while(currentDate <= endDate) {
                        const dateKey = currentDate.toDateString();
                        if(!groups[dateKey]) {
                            groups[dateKey] = [];
                        }
                        groups[dateKey].push(event);
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                });
                const sortedGroups = {};
                Object.keys(groups).sort((a,b) => new Date(a) - new Date(b)).forEach(key => {
                    sortedGroups[key] = groups[key];
                    sortedGroups[key].sort((a,b) => new Date(a.dtstart) - new Date(b.dtstart));
                });
                return sortedGroups;
            }

            const groupedListEvents = useMemo(() => groupEvents(sortedEvents), [sortedEvents]);
            const groupedSearchEvents = useMemo(() => groupEvents(filteredEvents), [filteredEvents]);

            const handleSearchInputChange = (e) => {
                setSearchQuery(e.target.value);
                setSelectedService(null); // Clear service filter when typing
            };

            const handleServiceSelect = (service) => {
                setSelectedService(prev => prev === service ? null : service); // Toggle selection
                setSearchQuery(''); // Clear text search when selecting a service
            };

            const isSearchActive = searchQuery.length > 0 || selectedService !== null;
            const serviceTypes = ['walk', 'drop-in', 'boarding', 'meet-and-greet'];
            
            if (!isAuthenticated) {
                return <PasswordScreen onCorrectPassword={handleLogin} />;
            }

            return (
                <div className="bg-[#141414] min-h-screen font-sans flex justify-center">
                    <div className="w-full max-w-md flex flex-col h-screen bg-[#141414] overflow-hidden">
                        
                        {/* Header */}
                        <div className="flex-shrink-0">
                            <CalendarHeader 
                                currentDate={currentDate} 
                                setCurrentDate={setCurrentDate} 
                                view={view}
                                onTodayClick={handleTodayClick}
                                setView={setView}
                                isSorted={isSorted}
                                setIsSorted={setIsSorted}
                            />
                        </div>
                        
                        {/* Main Content Area (Stretches to fill space) */}
                        <div className="flex-grow flex flex-col overflow-y-auto" ref={contentRef}>
                           {isLoading && <div className="flex-grow flex items-center justify-center text-white">Loading Calendar...</div>}
                           {error && <div className="flex-grow flex items-center justify-center text-red-400 p-4 text-center">{error}</div>}
                           {!isLoading && !error && (
                             <>
                                {view === 'calendar' && <CalendarGrid currentDate={currentDate} events={calendarVisibleEvents} onDayClick={handleDayClick} />}
                                
                                {view === 'list' && (
                                    <div className="p-4 h-full">
                                        <div className="space-y-4">
                                            {Object.keys(groupedListEvents).length > 0 ? Object.keys(groupedListEvents).map(dateKey => (
                                                <div key={dateKey} id={new Date(dateKey).toDateString() === todayDateString ? 'today-marker' : null}>
                                                    <h3 className="font-bold text-gray-300">{new Date(dateKey).toLocaleDateString('en-US', { weekday: 'short', month: 'long', day: 'numeric' })}</h3>
                                                    <ul className="mt-2 space-y-2">
                                                        {groupedListEvents[dateKey].map(event => (
                                                            <li key={`${event.uid}-${dateKey}`} onClick={() => handleEventClick(event, new Date(dateKey))} className="bg-white/5 rounded-lg flex overflow-hidden cursor-pointer hover:bg-white/10">
                                                                <div className={`w-1.5 flex-shrink-0 ${getBarColorForEventType(event.type)}`}></div>
                                                                <div className="p-3 flex items-center gap-3 flex-grow">
                                                                    <div className="w-20 text-sm text-gray-300">
                                                                        {formatTime(new Date(event.dtstart))}
                                                                    </div>
                                                                    <div className="flex-grow">
                                                                        <p className="font-semibold text-gray-100">{event.summary}</p>
                                                                    </div>
                                                                    <span className="text-xs text-gray-400 self-start font-roboto-mono">{formatEventType(event.type)}</span>
                                                                </div>
                                                            </li>
                                                        ))}
                                                    </ul>
                                                </div>
                                            )) : <p className="text-center text-gray-500 py-8">No events found.</p>}
                                        </div>
                                    </div>
                                )}

                                {view === 'search' && (
                                    <div className="p-4 h-full">
                                        <input type="text" value={searchQuery} onChange={handleSearchInputChange} placeholder="Search by pet name..." className="w-full px-4 py-2 text-sm bg-white/5 border border-white/10 text-white rounded-full focus:outline-none focus:ring-2 focus:ring-white/20 mb-4" />
                                        
                                        <div className="grid grid-cols-2 gap-2 mb-4">
                                            {serviceTypes.map(service => (
                                                <button key={service} onClick={() => handleServiceSelect(service)} className={`flex items-center gap-2 p-2 rounded-full text-sm transition-colors ${selectedService === service ? 'bg-white/20' : 'bg-white/5 hover:bg-white/10'}`}>
                                                    <div className={`w-3 h-3 rounded-full ${getBarColorForEventType(service)}`}></div>
                                                    <span className="text-gray-200">{formatEventType(service)}</span>
                                                </button>
                                            ))}
                                        </div>

                                        {isSearchActive && (
                                            <div className="space-y-4">
                                                {Object.keys(groupedSearchEvents).length > 0 ? Object.keys(groupedSearchEvents).map(dateKey => (
                                                    <div key={dateKey}>
                                                        <h3 className="font-bold text-gray-300">{new Date(dateKey).toLocaleDateString('en-US', { weekday: 'short', month: 'long', day: 'numeric' })}</h3>
                                                        <ul className="mt-2 space-y-2">
                                                            {groupedSearchEvents[dateKey].map(event => (
                                                                <li key={`${event.uid}-${dateKey}`} onClick={() => handleEventClick(event, new Date(dateKey))} className="bg-white/5 rounded-lg flex overflow-hidden cursor-pointer hover:bg-white/10">
                                                                    <div className={`w-1.5 flex-shrink-0 ${getBarColorForEventType(event.type)}`}></div>
                                                                    <div className="p-3 flex items-center gap-3 flex-grow">
                                                                        <div className="w-20 text-sm text-gray-300">
                                                                            {formatTime(new Date(event.dtstart))}
                                                                        </div>
                                                                        <div className="flex-grow">
                                                                            <p className="font-semibold text-gray-100">{event.summary}</p>
                                                                        </div>
                                                                        <span className="text-xs text-gray-400 self-start">{formatEventType(event.type)}</span>
                                                                    </div>
                                                                </li>
                                                            ))}
                                                        </ul>
                                                    </div>
                                                )) : <p className="text-center text-gray-500 py-8">No events found.</p>}
                                            </div>
                                        )}
                                    </div>
                                )}
                                {view === 'insights' && <InsightsPage events={events} currentDate={currentDate} isSorted={isSorted} setIsSorted={setIsSorted} />}
                                {view === 'settings' && <SettingsPage hiddenEventTypes={hiddenEventTypes} onToggleEventType={handleToggleEventType} onDeleteAllEvents={handleDeleteAllEvents} />}
                             </>
                           )}
                        </div>

                        {/* Footer Navigation */}
                        <div className="flex-shrink-0 border-t border-white/10 flex justify-around items-center p-2">
                            <button onClick={() => setView(v => v === 'insights' ? 'calendar' : 'insights')} className={`p-3 transition-colors ${view === 'insights' ? 'text-white' : 'text-[#7B7B7B]'}`}>
                                <Smile size={28} />
                            </button>
                            <button onClick={() => setView(v => v === 'list' ? 'calendar' : 'list')} className={`p-3 transition-colors ${view === 'list' ? 'text-white' : 'text-[#7B7B7B]'}`}>
                                {view === 'list' ? <CalendarIcon size={28} /> : <List size={28} />}
                            </button>
                            <button onClick={() => setIsAddModalOpen(true)} className="p-3 text-[#7B7B7B] transition-transform transform active:scale-90">
                                <PlusCircle size={32} />
                            </button>
                            <button onClick={() => setView(v => v === 'search' ? 'calendar' : 'search')} className={`p-3 transition-colors ${view === 'search' ? 'text-white' : 'text-[#7B7B7B]'}`}>
                                <Search size={28} />
                            </button>
                             <button onClick={() => setView(v => v === 'settings' ? 'calendar' : 'settings')} className={`p-3 transition-colors ${view === 'settings' ? 'text-white' : 'text-[#7B7B7B]'}`}>
                                <MoreHorizontal size={28} />
                            </button>
                        </div>
                    </div>

                    {/* Modals remain outside the main layout flow */}
                    <EventModal 
                        isOpen={isDayModalOpen} 
                        onClose={handleCloseModal} 
                        date={selectedDay.date}
                        events={modalEvents}
                        onEdit={handleEditEvent}
                        onDelete={handleDeleteEvent}
                        onDeleteSeries={handleDeleteSeries}
                    />
                    <AddEventForm 
                        isOpen={isAddModalOpen}
                        onAddEvents={handleAddEvents} 
                        eventToEdit={editingEvent}
                        onUpdateEvent={handleUpdateEvent}
                        onUpdateSeries={handleUpdateSeries}
                        onCancelEdit={handleCancelEdit}
                        isLocalOrPreview={isLocalOrPreview}
                    />
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
